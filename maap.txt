This document offers a rough map of this code, highlighting important files for our implementation of pruning in HPVsim and for replication of the results in our paper (https://dx.doi.org/10.2139/ssrn.5021341).

The examples directory contains files of interest for replicating results in the paper and performing experiments. Most of the work is in 'examples/Fabian Testing HPVsim informally', which we will abbreviate as 'examples/FTHI'

Work replication: 
-> examples/JulyAugustWork/generatingParamsForSyntheticData.py: this file performs a calibration on the existing Nigeria dataset, and then runs a simulation using the best-found paramter set from this calibration. The results of this simulation provide a rich synthetic dataset.
-> examples/FTHI/calibration.py: this file is a good rig for testing out different calibrtaions - including testing out different variants of pruning, and the different built-in plots (of particular interest are the detailed contour plots, which plot both completed and pruned trials. Examples of such plots are in our supplementary materials)
-> examples/FTHI/optuna_dashboard.ipynb: this ipynb notebook starts a server for the analysis of a calibrataion. It can take a while to load, so to check it is working correctly, try to load up a calibration with just a few dozen trials.
-> examples/FTHI/leaky_pruning_figure_code.py: this code rig generates results which compare outcomes when calibrating for a fixed amount of time, with leaky pruning over a range of leakinesses (which you specify as keys in the dictionaries on lines 129-133 and lines 136-139; ensure the set of dictionary keys agree between these two dictionaries), and a range of pruners (lines 141-145). Pick how many repeat trials you want for each leakiness-pruner pair with no_runs (line 135). Pick the time at which you cut off your calibrations with study_cutoff_time (line 57).
	-> you can change this rig to instead cut off calibrations after a set number of trials by removing the "optuna_callback=time_cutoff_callback" on line 169 and changing "no_trials=1000000" on line 127 to be however many trials you want each calibration to perform
-> examples/FTHI/timetests{Hyperband, Mediaan, Nop, SH2, SH3, SH4}.py: these files run a series of calibrations with differnet pruners (depending on the file name) and across a range of initial random seeds. They output the number of seconds it took to run each calibration, for the analysis of how long calibrations take (to get the time plots in the paper).
-> examples/FTHI/multirunner.py: this is something you may wish to experiment with, or use to get results faster - it is a crude variant on the Calibration class which allows for several calibrations to run simulatenously, potentailly with more than one worker each. This is in contrast to the standard Calibration class which only allows a single calibration to run at a time, with a calibration (in both cases) being handled by one or more workers. In the case where calibrations converge rather quickly, to a value which depends heavily on their starting conditions, it could make more sense to run several independant calibrations at once, rather than dedicating all the workers in your setup to a single calibration. As in our paper we found that it remains useful to spend longer on a single calibration (i.e. their learnign curves do not taper too quickly/too soon), this file has not come to much use, but it could be useful for you.

Following our implementation of pruning in HPVsim:
Go into the hpvsim folder to check out the actual module code. 
Relevant files are analysis.py, calibration.py, sim.py. 
'calibration -trying ram#.py' is an attempt at speeding up calibrations by only using primary storage for sharing information about a calibration between workers. Currently, a form of SQLlite is used, which I think must slow down things quite a bit. Optuna does support custom-designed storage for its optimisations, and I believe this must be possible, however I did not look too far into this, as it was not particularly relevant to our paper's investigation. Nonetheless, an intersting thing to look into and something that could offer great time savings for calibrations, where a LOT of reading from/writing to secondary storage happens (by looking in your file explorer/finder while performing a calibration, this becomes very apparent!).
